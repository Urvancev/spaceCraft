#include <stdio.h>
#include "defs.h"


struct Mius_DUS_Status
{
    unsigned int     i_Vkl:1;
    unsigned int     i_Tep_Got:1;
    unsigned int     i_Toch_Got:1;
    unsigned int     i_zashkal0:1; //т.е. на начальном этапе нет отказа на потенциометре
    unsigned int     i_zashkal1:1; //т.е. на начальном этапе нет отказа на потенциометре
    unsigned int     i_zashkal2:1; //т.е. на начальном этапе нет отказа на потенциометре
    unsigned int     i_vklAng:1; // включение Датчика угла
    unsigned int     i_vklMOM:1; // включение Датчика момента
    unsigned int     i_vklUsil:1; // включение Усилителя
    unsigned int     i_Spare:7;
};

struct Mius_DUS_Interface
{
    unsigned short   i_Counter;  /*16-разрядный счетчик*/

    short   i_V_w0;     /*Напряжение по каналу 0 -> -10240 +10240 миллиВольт*/
    short   i_V_w1;     /*Напряжение по каналу 1*/
    short   i_V_w2;     /*Напряжение по каналу 2*/

    struct Mius_DUS_Status s_Stat; /*Состояние датчика*/
};
typedef
struct DUS_s_type_struct
{
// входы/выходы
    double o_wCurrent[3];      // текущая скорость
//  float u_wInitial[3];       //начальная скорость
    int i_status;             // текущий статус ДУСа (готов или отказы)
 // float k_dus;              // Коэффициент чувствительности гироскопа
    struct Mius_DUS_Interface i_Input_Array;
    int i_vkl;                // Признак включения ДУС
} DUS_s_type;

DUS_s_type DUS_s;

void DUS_Main(double o_Omg[3],double o_wCurrent[3]) /*Вызывается на каждом такте*/
{
    /* На входе - интерфейсный массив от реального датчика или модели(через "программы обмена") */
    /* На выходе DUS_s.o_wCurrent */

//  float w0, w1, w2;                    // показания потенц. с ДУС или с его модели (угл.ск. в вольтах)

    double I_w[3];          // угловая скорость в радианах в секунду

    double dw0[3]={0,0,0};            // Случайный дрейф
    double M_ob[3][3];                // Матрица, обратная матрице ошибок установки M
    double M_op;                      // Определитель матрицы M
    double dx=0,dy=0,dz=0;            // Ошибки установки
    double B_ob[3][3];                // Матрица, обратная матрице погрешностей масштабного коэффициента B
    double B_op;                      // Определитель матрицы B
    double bx=0,by=0,bz=0;            // Погрешности масштабного коэффициента
    double Bw[3];                     // Bw = B_ob*(w-dw0)

//   на вход приходит  Стат. слово = 32 бита  ---------------------------------------------- ?????????

//    Dus_s.k_du=0.2;
    //DUS_s.k_dus=1.0;
DUS_s.i_vkl = 1;
DUS_s.i_status = 1;


    if (DUS_s.i_vkl)
    {   /*Вычисляем скорости на основании входных данных с модели*/
        // питание включено

      if (DUS_s.i_status)   // если i_status=1, то ДУС готов к работе ,т.е.
      {            // есть тепловая готовность и гироскоп достаточно раскручен
     // Движение гироскопа прекращается при   Мг = Му, т.е. когда
     // гироск-ий момент = упругому   H * w * cos B = K * B  , w - угл.скорость
     // Гироскопический момент уравновешивается упругим.
     // Вектор Н ДУС выставляют перпендикулярно к вектору измеряемой угловой скорости.
     // При малых углах  cos B = 1.  Тогда   B = H * w / K  (установившийся режим),
     // где B - угол бетта.
     // Измеряя угол B получают информацию об угловой скорости,
     // которая снимается с датчика угла (ДУ):
     //            U = Kду * B = Kду * H * w / K = Kдус * w
     // где Kду - крутизна характеристики ДУ по напряжению; w - измеряемая угл.ск.
     // Требуется  Kдус = const  - коэф-нт передачи ДУС - чувствительность ДУС
     // Угловая скорость (рад/с)   w = U/Kдус

        I_w[0] = o_Omg[0];//1553
        I_w[1] = o_Omg[1];
        I_w[2] = o_Omg[2];


        //Вычисление определителя матрицы M
        M_op = 1 + dx*dx + dy*dy + dz*dz;

        // Вычисление матрицы M_ob
        M_ob[0][0] = 1/M_op * (1+dx*dx);
        M_ob[0][1] = 1/M_op * (-dy+dx*dz);
        M_ob[0][2] = 1/M_op * (dx*dy+dz);

        M_ob[1][0] = 1/M_op * (dy+dx*dz);
        M_ob[1][1] = 1/M_op * (1+dz*dz);
        M_ob[1][2] = 1/M_op * (-dx+dy*dz);

        M_ob[2][0] = 1/M_op * (dx*dy-dz);
        M_ob[2][1] = 1/M_op * (dx+dy*dz);
        M_ob[2][2] = 1/M_op * (1+dy*dy);

        //Вычисление определителя матрицы B
       B_op = (1+bx)*(1+by)*(1+bz);

        // Вычисление матрицы M_ob
        B_ob[0][0] = 1/B_op * (1+by)*(1+bz);
        B_ob[1][1] = 1/B_op * (1+bx)*(1+bz);
        B_ob[2][2] = 1/B_op * (1+bx)*(1+by);

        B_ob[0][1] = B_ob[0][2] = B_ob[1][0] = B_ob[1][2] = B_ob[2][0] = B_ob[2][1] = 0;

        // Bw = B_ob*(w-dw0)
        Bw[0] = B_ob[0][0]*(I_w[0]-dw0[0]) + B_ob[0][1]*(I_w[1]-dw0[1]) + B_ob[0][2]*(I_w[2]-dw0[2]);
        Bw[1] = B_ob[1][0]*(I_w[0]-dw0[0]) + B_ob[1][1]*(I_w[1]-dw0[1]) + B_ob[1][2]*(I_w[2]-dw0[2]);
        Bw[2] = B_ob[2][0]*(I_w[0]-dw0[0]) + B_ob[2][1]*(I_w[1]-dw0[1]) + B_ob[2][2]*(I_w[2]-dw0[2]);

        // Угловая скорость по 3-м осям в ССК
        DUS_s.o_wCurrent[0] = M_ob[0][0]*Bw[0] + M_ob[0][1]*Bw[1] + M_ob[0][2]*Bw[2];
        DUS_s.o_wCurrent[1] = M_ob[1][0]*Bw[0] + M_ob[1][1]*Bw[1] + M_ob[1][2]*Bw[2];
        DUS_s.o_wCurrent[2] = M_ob[2][0]*Bw[0] + M_ob[2][1]*Bw[1] + M_ob[2][2]*Bw[2];
      }
    }
    else  /*Обнуляем, если нет питания прибора*/
    {
        DUS_s.o_wCurrent[0]=0;  // Скорости вращения по 3-м осям = 0
        DUS_s.o_wCurrent[1]=0;
        DUS_s.o_wCurrent[2]=0;
    }

    o_wCurrent[0] = DUS_s.o_wCurrent[0];
    o_wCurrent[1] = DUS_s.o_wCurrent[1];
    o_wCurrent[2] = DUS_s.o_wCurrent[2];
}
